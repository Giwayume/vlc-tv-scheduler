(function() {
var ue = Object.defineProperty;
var le = (r, e, t) => e in r ? ue(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var d = (r, e, t) => (le(r, typeof e != "symbol" ? e + "" : e, t), t);
const { ref: k, watch: g, defineComponent: ne, computed: ae } = Vue;
var V = /* @__PURE__ */ ((r) => (r.Empty = "empty", r.Value = "value", r.Range = "range", r.EveryX = "everyX", r.Combined = "combined", r.NoSpecific = "noSpecific", r))(V || {}), I = /* @__PURE__ */ ((r) => (r.Prefix = "prefix", r.Suffix = "suffix", r.Text = "text", r))(I || {});
class fe {
  constructor(e) {
    d(this, "field");
    d(this, "itemMap");
    this.field = e, this.itemMap = this.field.items.reduce(
      (t, n) => (t[n.value] = n, t),
      {}
    );
  }
  get id() {
    return this.field.id;
  }
  get items() {
    return this.field.items;
  }
  get onChange() {
    return this.field.onChange;
  }
  get segmentFactories() {
    return this.field.segmentFactories;
  }
  get min() {
    return this.items[0].value;
  }
  get max() {
    return this.items[this.items.length - 1].value;
  }
  getItem(e) {
    return this.itemMap[e];
  }
}
function ce(r, e, t = 1) {
  const n = [];
  for (let a = r; a <= e; a += t)
    n.push(a);
  return n;
}
class xe {
  constructor(e, t, n = 1) {
    d(this, "start");
    d(this, "end");
    d(this, "step");
    return this.start = e, this.end = t, this.step = n, new Proxy(this, {
      get: function(a, i) {
        const s = typeof i == "string" ? parseInt(i) : i;
        return typeof s == "number" && s >= 0 && s <= a.length ? a.start + a.step * s : Reflect.get(a, i);
      }
    });
  }
  get length() {
    return (this.end - this.start) / this.step + 1;
  }
  [Symbol.iterator]() {
    let e = -1;
    return {
      next: () => ({ value: this[++e], done: this[e + 1] === void 0 })
    };
  }
}
function E(r, e, t = (a) => a + "", n = (a) => a + "") {
  const a = [];
  for (const i of new xe(r, e))
    a.push({
      text: t(i),
      alt: n(i),
      value: i
    });
  return a;
}
function pe(r) {
  return {
    secondItems: E(0, 59, (e) => J(e, 2)),
    minuteItems: E(0, 59, (e) => J(e, 2)),
    hourItems: E(0, 23, (e) => J(e, 2)),
    dayItems: E(1, 31),
    monthItems: E(
      1,
      12,
      (e) => new Date(2021, e - 1, 1).toLocaleDateString(r, { month: "long" }),
      (e) => new Date(2021, e - 1, 1).toLocaleDateString(r, { month: "short" })
    ),
    dayOfWeekItems: E(
      0,
      6,
      (e) => new Date(2021, 0, 3 + e).toLocaleDateString(r, { weekday: "long" }),
      (e) => new Date(2021, 0, 3 + e).toLocaleDateString(r, { weekday: "short" })
    )
  };
}
function J(r, e) {
  const t = r + "";
  return t.length < e ? new Array(e - t.length).fill("0").join("") + r : t;
}
function H(r) {
  return r && typeof r == "object" && !Array.isArray(r);
}
function Y(r, ...e) {
  if (!H(r) || e.length === 0)
    return;
  const t = e.shift();
  if (H(t))
    for (const [n, a] of Object.entries(t))
      H(a) ? (H(r[n]) || (r[n] = {}), Y(r[n], t[n])) : r[n] = t[n];
  return e.length > 0 && Y(r, e), r;
}
function ie(r, ...e) {
  if (e.length === 0)
    return r;
  for (const t of e[0])
    if (t in r) {
      const n = ie(r[t], ...e.slice(1));
      if (n !== void 0)
        return n;
    }
}
function de(r) {
  for (let e = 1; e < r.length; e++)
    if (r[e - 1] + 1 !== r[e])
      return !1;
  return !0;
}
function me() {
  throw new Error("not implemented");
}
function ve(r, e, t = !0) {
  const n = [];
  for (let a = 0; a < r.length; a += e) {
    const i = r.slice(a, a + e);
    for (; t && i.length < e; )
      i.push(null);
    n.push(i);
  }
  return n;
}
class B {
  constructor(e) {
    d(this, "field");
    d(this, "type", V.NoSpecific);
    this.field = e;
  }
  toCron() {
    return "?";
  }
  toArray() {
    return [];
  }
  get items() {
    return {};
  }
  static fromString(e, t) {
    return e !== "?" ? null : new B(t);
  }
}
class M {
  constructor(e) {
    d(this, "field");
    d(this, "type", V.Empty);
    this.field = e;
  }
  toCron() {
    return "*";
  }
  toArray() {
    return [];
  }
  get items() {
    return {};
  }
  static fromString(e, t) {
    return e !== "*" ? null : new M(t);
  }
  static fromArray(e, t) {
    const { items: n } = t;
    if (e.length === 0)
      return new M(t);
    if (e.length !== n.length)
      return null;
    for (const a of n)
      if (!e.includes(a.value))
        return null;
    return de(n.map((a) => a.value)) ? new M(t) : null;
  }
}
const U = class U {
  constructor(e, t, n) {
    d(this, "field");
    d(this, "type", V.Range);
    d(this, "start");
    d(this, "end");
    this.field = e, this.start = t, this.end = n;
  }
  toCron() {
    return `${this.start}-${this.end}`;
  }
  toArray() {
    const e = this.start, t = this.end;
    return ce(e, t);
  }
  get items() {
    return {
      start: this.field.itemMap[this.start],
      end: this.field.itemMap[this.end]
    };
  }
  static fromString(e, t) {
    if (!U.re.test(e))
      return null;
    const { min: n, max: a } = t, i = e.split("-"), s = parseInt(i[0]), o = parseInt(i[1]);
    return s > o || s < n || o > a ? null : new U(t, s, o);
  }
};
d(U, "re", /^\d+-\d+$/);
let R = U;
const Z = (r, e, t) => {
  const n = r * Math.floor(e / r), a = [];
  for (let i = n; i <= t; i += r)
    i >= e && a.push(i);
  return a;
}, j = class j {
  constructor(e, t) {
    d(this, "field");
    d(this, "type", V.EveryX);
    d(this, "every");
    this.field = e, this.every = t;
  }
  toCron() {
    return `*/${this.every}`;
  }
  toArray() {
    const { min: e, max: t } = this.field;
    return Z(this.every, e, t);
  }
  get items() {
    return {
      every: this.field.itemMap[this.every]
    };
  }
  static fromString(e, t) {
    if (!j.re.test(e))
      return null;
    const [, n] = e.split("/"), a = parseInt(n), { min: i, max: s } = t;
    return Z(a, i, s).length == 0 ? null : new j(t, a);
  }
  static fromArray(e, t) {
    const { min: n, max: a } = t;
    if (e.length < 3)
      return null;
    const i = e[1] - e[0];
    if (i <= 1)
      return null;
    const s = n % i === 0 ? n : (Math.floor(n / i) + 1) * i;
    if (e.length !== Math.floor((a - s) / i) + 1)
      return null;
    for (const o of e)
      if (o % i !== 0)
        return null;
    return new j(t, i);
  }
};
d(j, "re", /^\*\/\d+$/);
let P = j;
class $ {
  constructor(e, t) {
    d(this, "field");
    d(this, "type", V.Value);
    d(this, "value");
    this.field = e, this.value = t;
  }
  toCron() {
    return `${this.value}`;
  }
  toArray() {
    return [this.value];
  }
  get items() {
    return {
      value: this.field.itemMap[this.value]
    };
  }
  static fromString(e, t) {
    const { min: n, max: a } = t, i = parseInt(e);
    return String(i) === e && i >= n && i <= a ? new $(t, i) : null;
  }
  static fromArray(e, t) {
    const { min: n, max: a } = t;
    if (e.length != 1)
      return null;
    const i = e[0];
    return i < n || i > a ? null : i;
  }
}
const T = class T {
  constructor(e, t = []) {
    d(this, "field");
    d(this, "segments");
    this.field = e, this.segments = t;
  }
  get type() {
    return this.segments.length == 1 ? this.segments[0].type : V.Range;
  }
  addSegment(e) {
    this.segments.push(e);
  }
  toCron() {
    return this.segments.map((e) => e.toCron()).join(",");
  }
  toArray() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.segments)
      t.toArray().forEach((n) => e.add(n));
    return Array.from(e);
  }
  get items() {
    return me();
  }
  static fromString(e, t) {
    const n = t.segmentFactories ?? T.segmentFactories;
    let a = [];
    for (const i of e.split(",")) {
      if (i === "*") {
        a = [new M(t)];
        break;
      }
      let s = null;
      for (const o of n)
        if (s = o(i, t), s !== null)
          break;
      if (s === null)
        return null;
      a.push(s);
    }
    return new T(t, a);
  }
  static fromArray(e, t) {
    const { min: n, max: a } = t, i = e[0], s = e[e.length - 1];
    if (i < n || s > a)
      return null;
    const o = [];
    let u = 0;
    for (let c = 0; c < e.length; c++)
      (e[c + 1] === void 0 || e[c + 1] - e[c] > 1) && (c === u ? o.push(new $(t, e[u])) : o.push(new R(t, e[u], e[c])), u = c + 1);
    return new T(t, o);
  }
};
d(T, "segmentFactories", [
  M.fromString,
  P.fromString,
  R.fromString,
  $.fromString
]);
let F = T;
function _(r, e) {
  return F.fromString(r, e);
}
function ye(r, e) {
  for (const t of [
    M.fromArray,
    P.fromArray,
    F.fromArray
  ]) {
    const n = t(r, e);
    if (n != null)
      return n;
  }
  return null;
}
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var he = Object.prototype.toString, L = Array.isArray || function(e) {
  return he.call(e) === "[object Array]";
};
function G(r) {
  return typeof r == "function";
}
function ge(r) {
  return L(r) ? "array" : typeof r;
}
function Q(r) {
  return r.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function ee(r, e) {
  return r != null && typeof r == "object" && e in r;
}
function Se(r, e) {
  return r != null && typeof r != "object" && r.hasOwnProperty && r.hasOwnProperty(e);
}
var we = RegExp.prototype.test;
function ke(r, e) {
  return we.call(r, e);
}
var Ce = /\S/;
function Oe(r) {
  return !ke(Ce, r);
}
var be = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function Ae(r) {
  return String(r).replace(/[&<>"'`=\/]/g, function(t) {
    return be[t];
  });
}
var We = /\s*/, Me = /\s+/, te = /\s*=/, Xe = /\s*\}/, qe = /#|\^|\/|>|\{|&|=|!/;
function Ie(r, e) {
  if (!r)
    return [];
  var t = !1, n = [], a = [], i = [], s = !1, o = !1, u = "", c = 0;
  function m() {
    if (s && !o)
      for (; i.length; )
        delete a[i.pop()];
    else
      i = [];
    s = !1, o = !1;
  }
  var x, y, A;
  function W(O) {
    if (typeof O == "string" && (O = O.split(Me, 2)), !L(O) || O.length !== 2)
      throw new Error("Invalid tags: " + O);
    x = new RegExp(Q(O[0]) + "\\s*"), y = new RegExp("\\s*" + Q(O[1])), A = new RegExp("\\s*" + Q("}" + O[1]));
  }
  W(e || b.tags);
  for (var l = new z(r), f, v, h, X, q, p; !l.eos(); ) {
    if (f = l.pos, h = l.scanUntil(x), h)
      for (var S = 0, w = h.length; S < w; ++S)
        X = h.charAt(S), Oe(X) ? (i.push(a.length), u += X) : (o = !0, t = !0, u += " "), a.push(["text", X, f, f + 1]), f += 1, X === `
` && (m(), u = "", c = 0, t = !1);
    if (!l.scan(x))
      break;
    if (s = !0, v = l.scan(qe) || "name", l.scan(We), v === "=" ? (h = l.scanUntil(te), l.scan(te), l.scanUntil(y)) : v === "{" ? (h = l.scanUntil(A), l.scan(Xe), l.scanUntil(y), v = "&") : h = l.scanUntil(y), !l.scan(y))
      throw new Error("Unclosed tag at " + l.pos);
    if (v == ">" ? q = [v, h, f, l.pos, u, c, t] : q = [v, h, f, l.pos], c++, a.push(q), v === "#" || v === "^")
      n.push(q);
    else if (v === "/") {
      if (p = n.pop(), !p)
        throw new Error('Unopened section "' + h + '" at ' + f);
      if (p[1] !== h)
        throw new Error('Unclosed section "' + p[1] + '" at ' + f);
    } else
      v === "name" || v === "{" || v === "&" ? o = !0 : v === "=" && W(h);
  }
  if (m(), p = n.pop(), p)
    throw new Error('Unclosed section "' + p[1] + '" at ' + l.pos);
  return Ee(Ve(a));
}
function Ve(r) {
  for (var e = [], t, n, a = 0, i = r.length; a < i; ++a)
    t = r[a], t && (t[0] === "text" && n && n[0] === "text" ? (n[1] += t[1], n[3] = t[3]) : (e.push(t), n = t));
  return e;
}
function Ee(r) {
  for (var e = [], t = e, n = [], a, i, s = 0, o = r.length; s < o; ++s)
    switch (a = r[s], a[0]) {
      case "#":
      case "^":
        t.push(a), n.push(a), t = a[4] = [];
        break;
      case "/":
        i = n.pop(), i[5] = a[2], t = n.length > 0 ? n[n.length - 1][4] : e;
        break;
      default:
        t.push(a);
    }
  return e;
}
function z(r) {
  this.string = r, this.tail = r, this.pos = 0;
}
z.prototype.eos = function() {
  return this.tail === "";
};
z.prototype.scan = function(e) {
  var t = this.tail.match(e);
  if (!t || t.index !== 0)
    return "";
  var n = t[0];
  return this.tail = this.tail.substring(n.length), this.pos += n.length, n;
};
z.prototype.scanUntil = function(e) {
  var t = this.tail.search(e), n;
  switch (t) {
    case -1:
      n = this.tail, this.tail = "";
      break;
    case 0:
      n = "";
      break;
    default:
      n = this.tail.substring(0, t), this.tail = this.tail.substring(t);
  }
  return this.pos += n.length, n;
};
function D(r, e) {
  this.view = r, this.cache = { ".": this.view }, this.parent = e;
}
D.prototype.push = function(e) {
  return new D(e, this);
};
D.prototype.lookup = function(e) {
  var t = this.cache, n;
  if (t.hasOwnProperty(e))
    n = t[e];
  else {
    for (var a = this, i, s, o, u = !1; a; ) {
      if (e.indexOf(".") > 0)
        for (i = a.view, s = e.split("."), o = 0; i != null && o < s.length; )
          o === s.length - 1 && (u = ee(i, s[o]) || Se(i, s[o])), i = i[s[o++]];
      else
        i = a.view[e], u = ee(a.view, e);
      if (u) {
        n = i;
        break;
      }
      a = a.parent;
    }
    t[e] = n;
  }
  return G(n) && (n = n.call(this.view)), n;
};
function C() {
  this.templateCache = {
    _cache: {},
    set: function(e, t) {
      this._cache[e] = t;
    },
    get: function(e) {
      return this._cache[e];
    },
    clear: function() {
      this._cache = {};
    }
  };
}
C.prototype.clearCache = function() {
  typeof this.templateCache < "u" && this.templateCache.clear();
};
C.prototype.parse = function(e, t) {
  var n = this.templateCache, a = e + ":" + (t || b.tags).join(":"), i = typeof n < "u", s = i ? n.get(a) : void 0;
  return s == null && (s = Ie(e, t), i && n.set(a, s)), s;
};
C.prototype.render = function(e, t, n, a) {
  var i = this.getConfigTags(a), s = this.parse(e, i), o = t instanceof D ? t : new D(t, void 0);
  return this.renderTokens(s, o, n, e, a);
};
C.prototype.renderTokens = function(e, t, n, a, i) {
  for (var s = "", o, u, c, m = 0, x = e.length; m < x; ++m)
    c = void 0, o = e[m], u = o[0], u === "#" ? c = this.renderSection(o, t, n, a, i) : u === "^" ? c = this.renderInverted(o, t, n, a, i) : u === ">" ? c = this.renderPartial(o, t, n, i) : u === "&" ? c = this.unescapedValue(o, t) : u === "name" ? c = this.escapedValue(o, t, i) : u === "text" && (c = this.rawValue(o)), c !== void 0 && (s += c);
  return s;
};
C.prototype.renderSection = function(e, t, n, a, i) {
  var s = this, o = "", u = t.lookup(e[1]);
  function c(y) {
    return s.render(y, t, n, i);
  }
  if (u) {
    if (L(u))
      for (var m = 0, x = u.length; m < x; ++m)
        o += this.renderTokens(e[4], t.push(u[m]), n, a, i);
    else if (typeof u == "object" || typeof u == "string" || typeof u == "number")
      o += this.renderTokens(e[4], t.push(u), n, a, i);
    else if (G(u)) {
      if (typeof a != "string")
        throw new Error("Cannot use higher-order sections without the original template");
      u = u.call(t.view, a.slice(e[3], e[5]), c), u != null && (o += u);
    } else
      o += this.renderTokens(e[4], t, n, a, i);
    return o;
  }
};
C.prototype.renderInverted = function(e, t, n, a, i) {
  var s = t.lookup(e[1]);
  if (!s || L(s) && s.length === 0)
    return this.renderTokens(e[4], t, n, a, i);
};
C.prototype.indentPartial = function(e, t, n) {
  for (var a = t.replace(/[^ \t]/g, ""), i = e.split(`
`), s = 0; s < i.length; s++)
    i[s].length && (s > 0 || !n) && (i[s] = a + i[s]);
  return i.join(`
`);
};
C.prototype.renderPartial = function(e, t, n, a) {
  if (n) {
    var i = this.getConfigTags(a), s = G(n) ? n(e[1]) : n[e[1]];
    if (s != null) {
      var o = e[6], u = e[5], c = e[4], m = s;
      u == 0 && c && (m = this.indentPartial(s, c, o));
      var x = this.parse(m, i);
      return this.renderTokens(x, t, n, m, a);
    }
  }
};
C.prototype.unescapedValue = function(e, t) {
  var n = t.lookup(e[1]);
  if (n != null)
    return n;
};
C.prototype.escapedValue = function(e, t, n) {
  var a = this.getConfigEscape(n) || b.escape, i = t.lookup(e[1]);
  if (i != null)
    return typeof i == "number" && a === b.escape ? String(i) : a(i);
};
C.prototype.rawValue = function(e) {
  return e[1];
};
C.prototype.getConfigTags = function(e) {
  return L(e) ? e : e && typeof e == "object" ? e.tags : void 0;
};
C.prototype.getConfigEscape = function(e) {
  if (e && typeof e == "object" && !L(e))
    return e.escape;
};
var b = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(r) {
    N.templateCache = r;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return N.templateCache;
  }
}, N = new C();
b.clearCache = function() {
  return N.clearCache();
};
b.parse = function(e, t) {
  return N.parse(e, t);
};
b.render = function(e, t, n, a) {
  if (typeof e != "string")
    throw new TypeError('Invalid template! Template should be a "string" but "' + ge(e) + '" was given as the first argument for mustache#render(template, view, partials)');
  return N.render(e, t, n, a);
};
b.escape = Ae;
b.Scanner = z;
b.Context = D;
b.Writer = C;
const re = {
  "*": {
    prefix: "每",
    suffix: "",
    text: "未知",
    "*": {
      empty: { text: "每 {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "每 {{every.value}}" }
    },
    month: {
      "*": { prefix: "的" },
      empty: { text: "每月" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "的" },
      empty: { text: "每日" },
      value: { text: "{{value.alt}}号" },
      range: { text: "{{start.alt}}号-{{end.alt}}号" }
    },
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "一周的每一天" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "的" },
      empty: { text: "每小时" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "每分钟" }
    }
  },
  minute: {
    text: "分"
  },
  hour: {
    text: "小时",
    minute: {
      "*": {
        prefix: ":",
        suffix: "分钟"
      },
      empty: { text: "每" }
    }
  },
  day: {
    text: "天"
  },
  week: {
    text: "周",
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "每天" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    }
  },
  month: {
    text: "月",
    dayOfWeek: {
      "*": { prefix: "和" }
    },
    day: {
      "*": { prefix: "的" }
    }
  },
  year: {
    text: "年",
    dayOfWeek: {
      "*": { prefix: "和" }
    }
  }
}, je = {
  "*": {
    prefix: "Hver",
    suffix: "",
    text: "Ukendt",
    "*": {
      empty: { text: "hver {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "hver {{every.value}}" }
    },
    month: {
      "*": { prefix: "i" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "på" }
    },
    dayOfWeek: {
      "*": { prefix: "på" },
      empty: { text: "hver dag i ugen" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "klokken" }
    },
    minute: {
      "*": { prefix: ":" }
    }
  },
  minute: {
    text: "Minut"
  },
  hour: {
    text: "Time",
    minute: {
      "*": {
        prefix: "på de(t)",
        suffix: "minutter"
      },
      empty: { text: "hver" }
    }
  },
  day: {
    text: "Dag"
  },
  week: {
    text: "Uge"
  },
  month: {
    text: "Måned",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  },
  year: {
    text: "År",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  }
}, Te = {
  "*": {
    prefix: "Jede",
    suffix: "",
    text: "Unknown",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "alle {{every.value}}" }
    },
    month: {
      "*": { prefix: "im" },
      empty: {
        prefix: "in",
        text: "jedem Monat"
      },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "den" },
      empty: {
        prefix: "an",
        text: "jedem Tag"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Tage"
      },
      noSpecific: {
        prefix: "an",
        text: "keinem bestimmten Tag"
      }
    },
    dayOfWeek: {
      "*": { prefix: "am" },
      empty: {
        prefix: "an",
        text: "jedem Wochentag"
      },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        prefix: "und",
        text: "keinem bestimmten Wochentag"
      }
    },
    hour: {
      "*": { prefix: "um" },
      empty: {
        prefix: "zu",
        text: "jeder Stunde"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Stunden"
      }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "jede Minute" },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Minuten"
      }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "jede Sekunde" },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Sekunden"
      }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Stunde",
    minute: {
      "*": {
        prefix: "zu",
        suffix: "Minute(n)"
      },
      empty: { text: "jeder" }
    }
  },
  day: {
    prefix: "Jeden",
    text: "Tag"
  },
  week: {
    text: "Woche"
  },
  month: {
    prefix: "Jedes",
    text: "Monat"
  },
  year: {
    prefix: "Jedes",
    text: "Jahr"
  },
  //quartz format
  "q-second": {
    text: "Sekunde"
  },
  "q-minute": {
    text: "Minute",
    second: {
      "*": {
        prefix: "und"
      }
    }
  },
  "q-hour": {
    text: "Stunde",
    minute: {
      "*": {
        prefix: "und"
      }
    },
    second: {
      "*": {
        prefix: "und"
      }
    }
  }
}, Re = {
  "*": {
    prefix: "Every",
    suffix: "",
    text: "Unknown",
    "*": {
      empty: { text: "every {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "every {{every.value}}" }
    },
    month: {
      "*": { prefix: "in" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "on" },
      noSpecific: {
        text: "no specific day"
      }
    },
    dayOfWeek: {
      "*": { prefix: "on" },
      empty: { text: "every day of the week" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        text: "no specific day of the week"
      }
    },
    hour: {
      "*": { prefix: "at" }
    },
    minute: {
      "*": { prefix: ":" }
    },
    second: {
      "*": { prefix: ":" }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Hour",
    minute: {
      "*": {
        prefix: "at",
        suffix: "minute(s)"
      },
      empty: { text: "every" }
    }
  },
  day: {
    text: "Day"
  },
  week: {
    text: "Week"
  },
  month: {
    text: "Month",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  },
  year: {
    text: "Year",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  },
  //quartz format
  "q-second": {
    text: "Second"
  },
  "q-minute": {
    text: "Minute",
    second: {
      "*": {
        prefix: "at",
        suffix: "second(s)"
      },
      empty: { text: "every" }
    }
  },
  "q-hour": {
    text: "Hour",
    minute: {
      "*": {
        prefix: "at"
      }
    }
  }
}, Pe = {
  "*": {
    prefix: "todos los",
    suffix: "",
    text: "Desconocido",
    "*": {
      empty: { text: "todos los {{ field.id }}" },
      value: { text: "{{ value.text }}" },
      range: { text: "{{ start.text }}-{{ end.text }}" },
      everyX: { text: "todos/as {{ every.value }}" }
    },
    month: {
      "*": { prefix: "en" },
      empty: { text: "todos los meses" },
      value: { text: "{{ value.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    day: {
      "*": { prefix: "en" },
      empty: { text: "todos los días" },
      value: { text: "los días {{ value.alt }}" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos los días de la semana" },
      value: { text: "los {{ value.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    hour: {
      "*": { prefix: "a" },
      empty: { text: "todas las horas" },
      value: { text: "las {{ value.text }}" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "todos los minutos" }
    }
  },
  minute: {
    prefix: "todos los",
    text: "minutos"
  },
  hour: {
    prefix: "todas las",
    text: "horas",
    minute: {
      "*": {
        prefix: "a los",
        suffix: "minutos"
      },
      empty: { text: "todos", prefix: "a", suffix: "los minutos" }
    }
  },
  day: {
    text: "Días"
  },
  week: {
    text: "Semanas"
  },
  month: {
    text: "Meses",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  },
  year: {
    text: "años",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  }
}, $e = {
  "*": {
    prefix: "Toutes",
    suffix: "",
    text: "Inconnu",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "tous les {{every.value}}" }
    },
    month: {
      "*": { prefix: "en" },
      empty: { prefix: "en", text: "tous les mois" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "le" },
      empty: { prefix: "à", text: "tous les jours" },
      everyX: { prefix: "", text: "tous les {{every.value}} jours" },
      noSpecific: { prefix: "à", text: "aucun jour particulier" }
    },
    dayOfWeek: {
      "*": { prefix: "le" },
      empty: { prefix: "à", text: "tous les jours de la semaine" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "et", text: "aucun jour de la semaine particulier" }
    },
    hour: {
      "*": { prefix: "à" },
      empty: { prefix: "à", text: "toutes les heures" },
      everyX: { prefix: "", text: "toutes les {{every.value}} heures" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "toutes les minutes" },
      everyX: { prefix: "", text: "toutes les {{every.value}} minutes" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "toutes les secondes" },
      everyX: { prefix: "", text: "toutes les {{every.value}} secondes" }
    }
  },
  minute: { text: "Minute" },
  hour: {
    text: "Heure",
    minute: { "*": { prefix: "à", suffix: "minute(s)" }, empty: { text: "toutes" } }
  },
  day: { prefix: "Tous", text: "Jour" },
  week: { text: "Semaine" },
  month: { prefix: "Tous", text: "Mois" },
  year: { prefix: "Tous", text: "Année" },
  //quartz format
  "q-second": { text: "Seconde" },
  "q-minute": { text: "Minute", second: { "*": { prefix: "et" } } },
  "q-hour": { text: "Heure", minute: { "*": { prefix: "et" } }, second: { "*": { prefix: "et" } } }
}, De = {
  "*": {
    prefix: "हर",
    suffix: "",
    text: "अज्ञात",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "{{every.value}} हर" }
    },
    month: {
      "*": { prefix: "में" },
      empty: { prefix: "के", text: "हर महीने" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "के" },
      empty: { prefix: "पर", text: "हर दिन" },
      everyX: { prefix: "", text: "{{every.value}} दिन हर" },
      noSpecific: { prefix: "पर", text: "कोई विशेष दिन नहीं" }
    },
    dayOfWeek: {
      "*": { prefix: "पर" },
      empty: { prefix: "पर", text: "हर सप्ताह" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "और", text: "कोई विशेष सप्ताह नहीं" }
    },
    hour: {
      "*": { prefix: "को" },
      empty: { prefix: "पर", text: "हर घंटे" },
      everyX: { prefix: "", text: "{{every.value}} घंटे हर" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "हर मिनट" },
      everyX: { prefix: "", text: "{{every.value}} मिनट हर" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "हर सेकंड" },
      everyX: { prefix: "", text: "{{every.value}} सेकंड हर" }
    }
  },
  minute: { text: "मिनट" },
  hour: { text: "घंटा", minute: { "*": { prefix: "पर", suffix: "मिनट" }, empty: { text: "हर" } } },
  day: { prefix: "हर", text: "दिन" },
  week: { text: "सप्ताह" },
  month: { prefix: "हर", text: "महीना" },
  year: { prefix: "हर", text: "साल" },
  //quartz format
  "q-second": { text: "सेकंड" },
  "q-minute": { text: "मिनट", second: { "*": { prefix: "और" } } },
  "q-hour": { text: "घंटा", minute: { "*": { prefix: "और" } }, second: { "*": { prefix: "और" } } }
}, Le = {
  "*": {
    prefix: "毎",
    suffix: "",
    text: "不明",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "{{every.value}}ごとに" }
    },
    month: {
      "*": { prefix: "に" },
      empty: { prefix: "の", text: "毎月" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎日" },
      everyX: { prefix: "", text: "{{every.value}}日ごとに" },
      noSpecific: { prefix: "に", text: "特定の日はなし" }
    },
    dayOfWeek: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎週" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "と", text: "特定の曜日はなし" }
    },
    hour: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎時" },
      everyX: { prefix: "", text: "{{every.value}}時間ごとに" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "毎分" },
      everyX: { prefix: "", text: "{{every.value}}分ごとに" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "毎秒" },
      everyX: { prefix: "", text: "{{every.value}}秒ごとに" }
    }
  },
  minute: { text: "分" },
  hour: { text: "時", minute: { "*": { prefix: "に", suffix: "分" }, empty: { text: "毎" } } },
  day: { prefix: "毎", text: "日" },
  week: { text: "週" },
  month: { prefix: "毎", text: "月" },
  year: { prefix: "毎", text: "年" },
  //quartz format
  "q-second": { text: "秒" },
  "q-minute": { text: "分", second: { "*": { prefix: "と" } } },
  "q-hour": { text: "時", minute: { "*": { prefix: "と" } }, second: { "*": { prefix: "と" } } }
}, Ue = {
  "*": {
    prefix: "Todo(a)",
    suffix: "",
    text: "Desconhecido",
    "*": {
      empty: { text: "todo {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "todo {{every.value}}" }
    },
    month: {
      "*": { prefix: "de" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      empty: { text: "todo mês" }
    },
    day: {
      "*": { prefix: "no(s) dia(s)" },
      empty: { text: "todos" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos dias da semana" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "às" },
      empty: { text: "cada hora" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "cada minuto" }
    }
  },
  minute: {
    text: "Minuto"
  },
  hour: {
    text: "Hora",
    minute: {
      "*": {
        prefix: "e",
        suffix: "minuto(s)"
      },
      empty: { text: "cada" }
    }
  },
  day: {
    text: "Dia"
  },
  week: {
    text: "Semana"
  },
  month: {
    text: "Mês",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  },
  year: {
    text: "Ano",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  }
}, Fe = {
  "*": {
    prefix: "Каждый",
    suffix: "",
    text: "Неизвестно",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "каждый {{every.value}}" }
    },
    month: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждом месяце" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждый день" },
      everyX: { prefix: "", text: "каждые {{every.value}} дня" },
      noSpecific: { prefix: "в", text: "нет определенного дня" }
    },
    dayOfWeek: {
      "*": { prefix: "по" },
      empty: { prefix: "по", text: "каждому дню недели" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "и", text: "нет определенного дня недели" }
    },
    hour: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждый час" },
      everyX: { prefix: "", text: "каждые {{every.value}} часа" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "каждую минуту" },
      everyX: { prefix: "", text: "каждые {{every.value}} минуты" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "каждую секунду" },
      everyX: { prefix: "", text: "каждые {{every.value}} секунды" }
    }
  },
  minute: { text: "Минута" },
  hour: {
    text: "Час",
    minute: { "*": { prefix: "в", suffix: "минут(а/ы)" }, empty: { text: "каждый" } }
  },
  day: { prefix: "Каждый", text: "День" },
  week: { text: "Неделя" },
  month: { prefix: "Каждый", text: "Месяц" },
  year: { prefix: "Каждый", text: "Год" },
  //quartz format
  "q-second": { text: "Секунда" },
  "q-minute": { text: "Минута", second: { "*": { prefix: "и" } } },
  "q-hour": { text: "Час", minute: { "*": { prefix: "и" } }, second: { "*": { prefix: "и" } } }
}, K = {
  empty: {},
  en: Re,
  de: Te,
  pt: Ue,
  es: Pe,
  da: je,
  zh: re,
  "zh-cn": re,
  ru: Fe,
  fr: $e,
  hi: De,
  ja: Le
};
class Ne {
  constructor(e) {
    d(this, "dict");
    this.dict = e;
  }
  getLocaleStr(...e) {
    const t = e.map((n) => [n, "*"]);
    return ie(this.dict, ...t) || "";
  }
  render(e, t, n, a, i) {
    const s = this.getLocaleStr(e, t, n, a);
    return b.render(s, i || {});
  }
}
function ze(r, e) {
  const [t] = r.split("-"), n = K[r.toLowerCase()] || K[t.toLowerCase()] || K.en, a = Y(n, e || {});
  return new Ne(a);
}
function He(r) {
  const { period: e, field: t, initialCron: n = "*", locale: a } = r, i = k(n), s = k(""), o = k([]), u = k(""), c = k(""), m = k(""), x = (l) => {
    const f = l instanceof F ? l.segments : [l];
    u.value = f.map((v) => a.render(e.value.id, t.id, v.type, I.Text, {
      field: t,
      ...v.items
    })).join(","), c.value = a.getLocaleStr(e.value.id, t.id, l.type, I.Prefix), m.value = a.getLocaleStr(e.value.id, t.id, l.type, I.Suffix);
  }, y = (l) => {
    const f = _(l, t);
    f != null ? (o.value = f.toArray(), x(f)) : s.value = `${l} is not a valid cron segment (${t.id})`;
  }, A = (l) => {
    if (i.value == "?" && l.length == 0)
      return;
    const f = ye(l, t);
    f != null ? (i.value = f.toCron(), x(f)) : s.value = `failed to convert ${l} to cron (${t.id})`;
  };
  y(n);
  const W = (l) => {
    const f = Array.from(l).sort((v, h) => v > h ? 1 : -1);
    o.value = f;
  };
  return g(i, (l) => {
    y(l);
  }), g(o, (l) => {
    A(l);
  }), g(e, () => {
    const l = _(i.value, t);
    l != null && x(l);
  }), {
    id: t.id,
    items: t.items,
    cron: i,
    selected: o,
    error: s,
    select: W,
    text: u,
    prefix: c,
    suffix: m
  };
}
function se(r, e = "*") {
  return new Array(r).fill(e).join(" ");
}
function Be(r) {
  return r !== void 0;
}
class Je {
  constructor() {
    d(this, "locale", "en");
    d(this, "format", "crontab");
  }
  initialValue(e, t = "*") {
    return se(e, t);
  }
  fields(e, t) {
    const n = e == "quartz", a = pe(t), i = (s) => (o, { segmentMap: u }) => {
      if (o.cron.value == "?")
        return;
      const c = u.get(s);
      c && (c.cron.value = "?");
    };
    return [
      ...n ? [{ id: "second", items: a.secondItems }] : [],
      { id: "minute", items: a.minuteItems },
      { id: "hour", items: a.hourItems },
      {
        id: "day",
        items: a.dayItems,
        onChange: n ? i("dayOfWeek") : void 0,
        segmentFactories: n ? [
          M.fromString,
          B.fromString,
          P.fromString,
          R.fromString,
          $.fromString
        ] : void 0
      },
      { id: "month", items: a.monthItems },
      {
        id: "dayOfWeek",
        items: a.dayOfWeekItems,
        onChange: n ? i("day") : void 0,
        segmentFactories: n ? [
          M.fromString,
          B.fromString,
          P.fromString,
          R.fromString,
          $.fromString
        ] : void 0
      }
    ];
  }
  periods(e) {
    const t = e == "quartz", n = t ? [{ id: "q-second", value: [] }] : [], a = t ? ["second"] : [], i = t ? "q-" : "";
    return [
      ...n,
      { id: i + "minute", value: [...a] },
      { id: i + "hour", value: ["minute", ...a] },
      { id: "day", value: ["hour", "minute", ...a] },
      { id: "week", value: ["dayOfWeek", "hour", "minute", ...a] },
      { id: "month", value: ["day", "dayOfWeek", "hour", "minute", ...a] },
      { id: "year", value: ["month", "day", "dayOfWeek", "hour", "minute", ...a] }
    ];
  }
}
function Qe(r) {
  const e = new Je(), t = r.locale ?? e.locale, n = r.format ?? e.format, { customLocale: a, fields: i = e.fields(n, t) } = r, s = r.initialValue ?? e.initialValue(i.length), o = ze(t, a), u = (r.periods ?? e.periods(n)).map((p) => ({
    ...p,
    text: o.getLocaleStr(p.id, I.Text)
  })), c = u.find((p) => p.id == r.initialPeriod) ?? u[u.length - 1], m = k(s), x = k(""), y = k(c), A = k(""), W = k(""), l = i.map((p) => He({ field: new fe(p), locale: o, period: y })), f = new Map(l.map((p) => [p.id, p])), v = ae(() => y.value.value.map((p) => {
    const S = f.get(p);
    if (Be(S))
      return S;
    throw Error("${fieldId} not found");
  })), h = (p) => {
    if (!p) {
      m.value = se(i.length);
      return;
    }
    const S = p.split(" ");
    if (S.length !== i.length) {
      x.value = "invalid pattern";
      return;
    }
    for (let w = 0; w < S.length; w++)
      l[w].cron.value != S[w] && (l[w].cron.value = S[w]);
    x.value = "";
  };
  h(s);
  const X = () => {
    m.value = l.map((p) => y.value.value.includes(p.id) || p.cron.value == "?" ? p.cron.value : "*").join(" ");
  }, q = () => {
    A.value = o.getLocaleStr(y.value.id, I.Prefix), W.value = o.getLocaleStr(y.value.id, I.Suffix);
  };
  return q(), g(m, h), g(y, () => {
    X(), q();
  }), l.forEach((p, S) => {
    g(p.cron, () => {
      var w, O;
      (O = (w = i[S]).onChange) == null || O.call(w, p, { segmentMap: f }), X();
    }), g(p.error, (w) => {
      x.value = w;
    });
  }), {
    cron: m,
    error: x,
    segments: l,
    selected: v,
    period: {
      select: (p) => {
        const S = u.map((w) => w.id).indexOf(p);
        S != -1 && (y.value = u[S]);
      },
      selected: y,
      items: u,
      prefix: A,
      suffix: W
    }
  };
}
function Ke(r, { emit: e }) {
  const t = {
    ...r,
    initialValue: r.modelValue,
    initialPeriod: r.period
  }, n = Qe(t);
  return g(
    () => r.modelValue,
    (a) => {
      a && (n.cron.value = a);
    }
  ), g(
    () => r.period,
    (a) => {
      a && n.period.select(a);
    }
  ), g(n.cron, (a) => {
    e("update:model-value", a);
  }), g(n.period.selected, (a) => {
    e("update:period", a.id);
  }), g(n.error, (a) => {
    e("error", a);
  }), n;
}
const Ye = () => ({
  /**
   * The value of the cron expression
   *
   * @defaultValue crontab: `* * * * *`, quartz: `* * * * * *`
   */
  modelValue: {
    type: String
  },
  /**
   * The id of a period to select
   *
   * @defaultValue last entry of `CronCoreProps.periods`
   */
  period: {
    type: String
  },
  /**
   * The format of the cron expression, either crontab or quartz
   *
   * @defaultValue `crontab`
   */
  format: {
    type: String
  },
  /**
   * The locale of the component, such as `en`, `de`, etc.
   *
   * @defaultValue `en`
   */
  locale: {
    type: String
  },
  /** The segments of the cron expression, such as second, minute, hour, etc. */
  fields: {
    type: Array
  },
  /** The periods to select, e.g. Every month, day, etc.  */
  periods: {
    type: Array
  },
  /** The custom locale object, used to override values of the current {@link Localization} */
  customLocale: {
    type: Object
  },
  /** Number of columns in the dropdown,
   * e.g. the possible values of minute (0-59) will be displayed in a grid with 5 columns
   *
   * @defaultValue
   * ```
   * {
   *    second: 5,
   *    minute: 5,
   *    hour: 4,
   *    day: 4,
   *  }
   * ```
   */
  cols: {
    type: Object,
    default: () => ({
      second: 5,
      minute: 5,
      hour: 4,
      day: 4
    })
  },
  /** Disable the cron editor */
  disabled: {
    type: Boolean,
    default: !1
  }
}), Ge = ne({
  name: "VueCronCore",
  props: Ye(),
  emits: ["update:model-value", "update:period", "error"],
  setup(r, e) {
    const { error: t, selected: n, period: a } = Ke(r, e);
    return () => {
      var s, o;
      const i = {
        error: t,
        fields: n.value.map((u) => ({
          id: u.id,
          items: u.items,
          cron: u.cron.value,
          selectedStr: u.text.value,
          events: {
            "update:model-value": u.select
          },
          attrs: {
            modelValue: u.selected.value
          },
          prefix: u.prefix.value,
          suffix: u.suffix.value
        })),
        period: {
          attrs: {
            modelValue: a.selected.value.id
          },
          events: {
            "update:model-value": a.select
          },
          items: a.items,
          prefix: a.prefix.value,
          suffix: a.suffix.value
        }
      };
      return (o = (s = e.slots).default) == null ? void 0 : o.call(s, i);
    };
  }
});
function Ze(r) {
  const { items: e } = r, t = /* @__PURE__ */ new Set(), n = k(0), a = () => {
    n.value = n.value + 1;
  }, i = (x) => {
    e.indexOf(x) != -1 && (t.add(x), a());
  }, s = (x) => t.has(x), o = (x) => {
    t.delete(x) && a();
  };
  return {
    values: t,
    add: i,
    toggle: (x) => {
      s(x) ? o(x) : i(x);
    },
    has: s,
    remove: o,
    clear: () => {
      t.clear(), a();
    },
    updated: n,
    equals: (x) => {
      if (x.length != t.size)
        return !1;
      for (const y of x)
        if (!t.has(y))
          return !1;
      return !0;
    }
  };
}
function _e() {
  return {
    modelValue: {
      type: [String, Number, Array]
    },
    selection: {
      type: String
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    items: {
      type: Array,
      default: () => []
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    cols: {
      type: Number,
      default: 1
    },
    itemText: {
      type: [String, Function],
      default: "text"
    },
    itemValue: {
      type: [String, Function],
      default: "value"
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  };
}
function oe(r) {
  const { items: e, cols: t = 1, multiple: n = !1, itemText: a = "text", itemValue: i = "value" } = r, s = Ze(r), o = n ? k([]) : k(null), u = k(""), c = (f) => {
    n ? s.toggle(f) : (s.clear(), s.add(f));
  }, m = (f) => typeof i == "function" ? i(f) : f[i], x = (f) => typeof a == "function" ? a(f) : f[a], y = new Map(e.map((f) => [m(f), f])), A = (f) => {
    s.equals(f) || (s.clear(), f.forEach((v) => c(v)));
  }, W = (f) => {
    f = Array.isArray(f) ? f : [f];
    const v = f.map((h) => y.get(h)).filter((h) => !!h);
    A(v);
  };
  g(s.updated, () => {
    const f = Array.from(s.values);
    o.value = n ? f.map(m) : m(f[0]), u.value = f.map(x).join(",");
  });
  const l = ae(() => n ? !Array.isArray(o.value) || o.value.length == 0 : !!o.value);
  return {
    ...s,
    select: c,
    selected: o,
    selectedStr: u,
    itemRows: ve(e, t),
    setItems: A,
    setValues: W,
    isEmpty: l
  };
}
function rt(r, e, { emit: t }) {
  const n = oe(r);
  return g(n.selected, () => {
    t("update:model-value", n.selected.value);
  }), g(
    e,
    (a) => {
      a && n.setValues(a);
    },
    { immediate: !0 }
  ), n;
}
const nt = ne({
  name: "RenderlessSelect",
  props: {
    ..._e(),
    modelValue: {
      type: [String, Number, Array]
    },
    selection: {
      type: String
    },
    clearable: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e, slots: t }) {
    const n = oe(r);
    return g(n.selected, () => {
      e("update:modelValue", n.selected.value);
    }), g(
      () => r.modelValue,
      (a) => {
        a && n.setValues(a);
      },
      { immediate: !0 }
    ), () => {
      var i;
      const a = {
        selectedStr: r.selection || n.selectedStr.value,
        modelValue: r.modelValue,
        items: r.items,
        select: n.select,
        isSelected: n.has,
        clearable: r.clearable && !n.isEmpty.value,
        clear: n.clear,
        cols: r.cols,
        rows: n.itemRows.length,
        itemRows: n.itemRows,
        multiple: r.multiple,
        itemText: r.itemText,
        itemValue: r.itemValue
      };
      return (i = t.default) == null ? void 0 : i.call(t, a);
    };
  }
}), at = {
  install: (r) => {
    r.component("CronCore", Ge);
  }
};
window.VueJsCronCore = {
  CronCore: Ge,
  CronCorePlugin: at,
  CronType: V,
  FieldWrapper: fe,
  Locale: Ne,
  RenderlessSelect: nt,
  TextPosition: I,
  cronCoreProps: Ye,
  default: at,
  defaultItems: pe,
  genItems: E,
  getLocale: ze,
  pad: J,
  selectProps: _e,
  setupCron: Ke,
  setupSelect: rt,
  splitArray: ve,
  useCron: Qe,
  useSelect: oe
};
})();
